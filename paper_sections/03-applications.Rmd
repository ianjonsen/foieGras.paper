---
output:
  pdf_document: default
  html_document: default
  word_document: default
---
# 3 | Applications

```{r part_3_premble, include=FALSE}
#### Code for part 3: Applications ####
```
We illustrate the main capabilities of `foieGras` through a set of applications that are for demonstration purposes. Complete code for reproducing the applications and for gaining a deeper understanding of `foieGras` functions are provided in the Supporting Information. Data used in the application are available [here](http://url.org).

## 3.1 | SSM validation with prediction residuals
We used a sub-adult male southern elephant seal (*Mirounga leonina*) track included as example data in `foieGras` (`sese2`, id: ct36-E-09), sourced from from the Australian Integrated Marine Observing System (IMOS; data publicly available via [imos.aodn.org.au](http://imos.aodn.org.au)) deployments at Iles Kerguelen in collaboration with the French IPEV and SNO-MEMO programmes. The data are temporally irregular Argos Least-Squares locations. We fitted both the `rw` and `crw` models using `fit_ssm()` with a speed filter threshold (`vmax`) of 4 ms^-1^ and a 12-h time step. We calculated prediction residuals using `osar()`, and then used the generic `plot` method for `osar` residuals to assess and compare the model fits (Fig. \ref{fig:ex1}). R code is available in Appendix S1 (Supporting Information).

```{r ex31, echo=FALSE, message=FALSE, results='markup', fig.width=7, fig.height=7.5, cache=TRUE, fig.cap="\\label{fig:ex1} State-space model fits to a southern elephant seal track with finer scale detail inset (a), and diagnostic plots for assessing goodness-of-fit of the `rw` (b - prediction residual time-series; d - prediction residual autocorrelation) and `crw` (c,e) state-space models. All residual plots generated using the `plot.osar` function."}

load("../data/ex31.RData")

dat <- grab(fit.rw[1,], "d", as_sf = TRUE) |> 
  sf::st_transform("+proj=stere +lon_0=90 +units=km")
loc.rw <- grab(fit.rw[1,], "f", as_sf = TRUE) |>
  sf::st_transform("+proj=stere +lon_0=90 +units=km") 
line.rw <- loc.rw |>
  dplyr::group_by(id) |>
  dplyr::summarise(do_union = FALSE, .groups = "drop") |>
  sf::st_cast("MULTILINESTRING")
loc.crw <- grab(fit.crw[1,], "f", as_sf = TRUE) |>
  sf::st_transform("+proj=stere +lon_0=90 +units=km") 
line.crw <- loc.crw |>
  dplyr::group_by(id) |>
  dplyr::summarise(do_union = FALSE, .groups = "drop") |>
  sf::st_cast("MULTILINESTRING")

line.ssm <- bind_rows(line.rw, line.crw) |>
  mutate(SSM = c("rw","crw")) |>
  select(id, SSM, geometry)

zbox <- structure(list(id = c(1,1,1,1,1), 
                       lon = c(107, 110.25, 110.25, 107, 107), 
                       lat = c(-66.5, -66.5, -64.9, -64.9, -66.5)), 
                  class = "data.frame", row.names = c(NA, -5L))

prj <- sf::st_crs(line.ssm)

zbox_sf <- zbox %>%
  sf::st_as_sf(coords = c("lon","lat"), crs = 4326) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(geometry = sf::st_combine(geometry)) %>%
  sf::st_cast("POLYGON")

bb_zbox <- sf::st_bbox(zbox_sf)

pA <- ggplot() +
  geom_sf(data = dat, 
             col = "orange", 
             size = 1.25) +
  geom_sf(data = line.ssm,
            aes(colour = SSM)) +
  geom_sf(data = zbox_sf, size = 0.5, colour = "black", fill = NA) +
  scale_colour_manual(values = c("firebrick", "dodgerblue")) +
  labs(x = element_blank(), y = element_blank()) +
  theme_minimal() +
  theme(axis.text = element_text(size = 8),
        legend.key.size = unit(c(6, 3), "mm"),
        legend.title = element_text(size = 9),
        legend.text = element_text(size = 8),
        legend.position = c(0.2,0.2))

pAsub1 <- ggplot() +
  geom_sf(data = dat, 
             col = "orange", 
             size = 1) +
  geom_sf(data = line.ssm,
            aes(colour = SSM)) +
  coord_sf(xlim = c(bb_zbox[1], bb_zbox[3]), 
           ylim = c(bb_zbox[2], bb_zbox[4]), 
           crs = prj, 
           expand = FALSE) +
  scale_colour_manual(values = c("firebrick", "dodgerblue"), guide = "none") +
  labs(x = element_blank(), y = element_blank()) +
  theme_minimal() +
  theme(axis.text = element_blank(),
        panel.background = element_rect(colour = "white"),
        panel.border = element_rect(fill=NA, size=0.5))

pAsub1 <- ggplotGrob(pAsub1)

foo <- sf::st_bbox(dat)

pAA <- pA + 
  annotation_custom(grob = pAsub1, 
                             xmin = foo$xmin + (foo$xmax - foo$xmin) * 0.35, 
                             xmax = foo$xmin + (foo$xmax - foo$xmin) * 1.30, 
                             ymin = foo$ymin + (foo$ymax - foo$ymin) * 0.35, 
                             ymax = foo$ymin + (foo$ymax - foo$ymin) * 1.05)

p1 <- plot(res.rw, "ts") + 
  xlab(element_blank()) + 
  ylab("Residuals") +
  theme(axis.text.x = element_text(size=7, angle=45), 
        axis.title.y = element_text(size = 8),
        strip.text.y = element_blank(),
        axis.title.x = element_blank())

p2 <- plot(res.rw, "acf") + 
  theme(strip.text.y = element_blank(),
        axis.text = element_text(size = 8),
        axis.title = element_text(size = 8))

p3 <- plot(res.crw, "ts") + 
  ylab(element_blank()) + 
  xlab(element_blank()) + 
  theme(axis.text.x = element_text(size=7, angle=45), 
        strip.text.y = element_blank(),
        axis.title.x = element_blank())

p4 <- plot(res.crw, "acf") + 
  ylab(element_blank()) + 
  theme(strip.text.y = element_blank(),
        axis.text = element_text(size = 8),
        axis.title = element_text(size = 8))

pAA / (p1 | p3) / (p2 | p4) +
  plot_layout(widths = c(3,3,3),
              heights = c(3,1,1)) +
  patchwork::plot_annotation(tag_levels = "a") &
  theme(plot.tag = element_text(size = 9))
```

Plots of predicted states on top of the observations suggest both models yield similar global fits (Fig. \ref{fig:ex1}a; blue versus red lines), but discrepancies are visible at a local scale (Fig. \ref{fig:ex1}a, inset). Predicted locations from the two models differ by a median 6.62 km (range: 0.02, 53.02 km), and there are marked trends in the residuals for the `rw` model fit (Fig. \ref{fig:ex1}b) with significantly positive autocorrelation in both the x and y directions (Fig. \ref{fig:ex1}d). The `crw` prediction residuals show no trend through time and have little autocorrelation (Fig. \ref{fig:ex1}c,e), implying the `crw` process model is a better fit to the data.

## 3.2 | Inferring move persistence  
To illustrate how move persistence ($\gamma_t$) can be estimated from GPS data, we use four little penguin (*Eudyptula minor*) tracks of daily foraging trips during the chick-rearing period from Montague Island, NSW, Australia \citep[described in][]{Phillips:2022}. The data are temporally irregular GPS locations, with high frequency sampling (mean 15 s) intermittently disrupted by the birds' diving behaviour, and are assumed to have minimal measurement error. We fitted the `crw` SSM to the GPS data to predict temporally regular locations at 5-min intervals, and assumed consistently small bivariate normal location measurement errors (ie. $\pm$ 30 m sd). We then used `fit_mpm()` to estimate $\gamma_t$ from these regularized locations. Finally, we visually compared $\gamma_t$ estimates with prey capture events inferred from accelerometry data \citep[see][for details]{Carroll:2014} to ascertain whether reduced $\gamma_t$ is indicative of active foraging by these penguins.

R code is available in Appendix S2 (Supporting Information). We provide an extra application to illustrate how move persistence can be inferred from Argos data using `fit_ssm()` (Appendix S3).

```{r ex32, echo=FALSE, message=FALSE, results='markup', fig.width=7, fig.height=5, cache=TRUE, fig.cap="\\label{fig:ex32} Inferred move persistence, $\\gamma_t$, 1-D time-series (a-d; grey envelopes are 95 % CI's) and along SSM-predicted little penguin tracks (e). Location symbol sizes are proportional to the number of prey capture events, inferred from accelerometry data, at 5-min intervals corresponding to the SSM predicted location times."}
load("../data/ex32_lipe.RData")

p <- plot(fmp, ncol = 2, pages = 1, ask = FALSE, pal = "Plasma") &
  theme(legend.position = "none",
        plot.title = element_blank(),
        axis.text = element_text(size = 6),
        panel.grid.minor = element_blank())
## adjust x-axis date labels for clean manuscript figure
p[[1]] <- p[[1]] & 
  scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
p[[2]] <- p[[2]] & 
  scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
p[[3]] <- p[[3]] & 
  scale_x_datetime(date_breaks = "4 hours", date_labels = "%H:%M")
p[[4]] <- p[[4]] & 
  scale_x_datetime(date_breaks = "5 hours", date_labels = "%H:%M")

## function to merge track & predation events
merge.tracks.preds <- function(tracks, preds){
  # drop tracks not in events
  tracks$id <- as.character(tracks$id)
  tracks <- tracks[tracks$id %in% unique(preds$id),]
  tracks$preyCount <- 0

  predsl <- split(preds, with(preds, interaction(id)), drop = TRUE)
  # Unique events
  uniqueEventsl2 <- lapply(predsl, 
                           function(x) x[round(diff(as.POSIXct(x$date))) > 2,])

  # Loop events
  tracks <- split(tracks, tracks$id)
  for (i in 1:length(tracks)){
    # go through events and find the nearest track timestamp for each
    events <- uniqueEventsl2[[tracks[[i]]$id[1]]]
    events$idx <- sapply(events$date, function(dt)
      which.min(abs(as.numeric(difftime(dt, tracks[[i]]$date, unit='sec')))))
    # populate tracks
    for (idx in unique(events$idx)){
      tracks[[i]]$preyCount[idx] <- sum(events$idx == idx)
    }
  }
  # merge tracks back together
  tracks <- do.call(rbind, tracks)
  row.names(tracks) <- NULL
  return(tracks)
}

peng.ssm_sf <- grab(fit, "p", as_sf = TRUE)

## aggregate prey capture events to SSM location times & append
peng.ssm_sf <- merge.tracks.preds(peng.ssm_sf, svm.pc)

## append move persistence estimates
peng.ssm_sf <- peng.ssm_sf %>% mutate(g = grab(fmp, "f")$g)

## expand limits to preserve map boundaries
bb <- sf::st_bbox(peng.ssm_sf)
bb["xmin"] <- bb["xmin"] - diff(bb[c(1,3)]) * 0.7/2
bb["xmax"] <- bb["xmax"] + diff(bb[c(1,3)]) * 0.3/2
bb["ymin"] <- bb["ymin"] - diff(bb[c(2,4)]) * 0.2/2
bb["ymax"] <- bb["ymax"] + diff(bb[c(2,4)]) * 0.2/2

my.aes <- aes_lst(conf = F, line = T, mp_pal = hcl.colors(n=100, "Plasma"))
my.aes$df$size[1] <- 1

m <- map(
  fit,
  fmp,
  what = "p",
  aes = my.aes,
  map_type = "cartolight",
  zoomin = 1,
  normalise = FALSE,
  silent = TRUE
) + 
  geom_sf(data=peng.ssm_sf %>% filter(preyCount > 0), 
          aes(size = preyCount, fill = g), 
          shape = 21, 
          stroke = 0.3,
          inherit.aes = TRUE) +
  scale_size(breaks = c(1,10,20), 
             range = c(1, 4), 
             name = "prey\ncaptures",
             guide = "none") +
  scale_fill_viridis_c(option = "C", 
                       begin = min(peng.ssm_sf$g), 
                       end = max(peng.ssm_sf$g),
                       guide = "none") +
  ggspatial::annotation_scale(height = unit(0.15, "cm"), 
                              aes(location = "br")) +
  xlab(element_blank()) +
  ylab(element_blank()) +
  coord_sf(xlim = bb[c(1,3)], 
            ylim = bb[c(2,4)], 
            expand = TRUE, 
            crs = sf::st_crs(peng.ssm_sf)) +
  scale_x_continuous(breaks = pretty(seq(150.13, 150.26, l = 4), n = 3)) +
  scale_y_continuous(breaks = pretty(seq(-36.5, -36.24, l = 5), n = 4)) +
  theme(legend.position = c(0.25,0.05),
        legend.direction = "horizontal",
        legend.key.width = unit(5, "mm"),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        panel.grid = element_line(colour = "grey40"),
        panel.background = element_blank(),
        panel.ontop = TRUE)

label.df <- data.frame(tag = c("a","b","c","d"), 
                        x = c(0.3, 0.8, 0.15, 0.83) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                        y = c(0.85, 0.15, 0.4, 0.5) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"])
names.df <- data.frame(tag = c("Montague\nIsland"),
                       x = 0.92 * (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                       y = 0.91 * (bb["ymax"] - bb["ymin"]) + bb["ymin"])

m <- m + 
  geom_text(data = label.df, aes(x,y,label=tag), size = 3) +
  geom_text(data = names.df, aes(x,y,label=tag), size = 2.5)

## make custom prey capture legend for location symbol size
pc.title <- data.frame(tag = "prey\ncaptures",
                       x = 0.05 * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                       y = 0.1 * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"])
pc.df <- data.frame(x = c(0.15, 0.205, 0.26, 0.33) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                    y = rep(0.11, 4) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"],
                    size = c(1, 1, 6, 15))
pc.labels <- data.frame(x = c(0.15, 0.205, 0.26, 0.33) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                    y = rep(0.08, 4) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"],
                    tag = c("0", "1", "10", "20"))

m <- m +
  geom_text(data = pc.title, 
            aes(x, y, label = tag), 
            size = 2, 
            inherit.aes = FALSE) +
  geom_point(data = pc.df[1,], 
             aes(x, y), 
             shape = 21,
             size = 1, 
             fill = "#EDB300",
             colour = "#EDB300",
             inherit.aes = FALSE,
             show.legend = FALSE) +
  geom_point(data = pc.df[2:4,], 
             aes(x, y, size = size), 
             shape = 21,
             stroke = 0.3,
             fill = NA,
             inherit.aes = FALSE,
             show.legend = FALSE) +
  geom_text(data = pc.labels,
            aes(x, y, label = tag), 
            size = 2,
            inherit.aes = FALSE)

## plot movement persistence 1-D time-series and map along 2-D tracks
(p | m) +
  plot_layout(widths = c(2.2, 3)) +
  plot_annotation(tag_levels = "a") &
  theme(plot.tag = element_text(size = 9))
```

The little penguin GPS tracks did not exhibit strong contrast in move persistence, with $\gamma_t$ declining below 0.5 for only two of the birds (Fig. \ref{fig:ex32}a-d). Nonetheless, the move persistence estimates highlight change in movement pattern over the course of the penguins' daily foraging trips (Fig. \ref{fig:ex32}e). The penguins departed Montague Is. with relatively fast movements, three directed southward (Fig. \ref{fig:ex32} tracks b-d in e) and one less directed and remaining close to the island (track a), before slowing down and engaging in meandering movements (orange - red in Fig. \ref{fig:ex32}e). Lower $\gamma_t$ was associated with consistently higher and more frequent prey captures, implying that low move persistence can be indicative of foraging activity by these penguins. The spatially diffuse bouts of lower move persistence may reflect the fine-scale patchiness of the penguins' forage-fish prey with search and prey-capture occurring both within and among discrete neighbouring prey aggregations \citep{Carroll:2017}.  

## 3.3 | Simulating tracks from `foieGras` model fits

To illustrate how to simulate tracks from `foieGras` model fits we use a juvenile harp seal (*Pagophilus groenlandicus*) tracked from the Gulf of St Lawrence, Canada, and \citep[described in][]{Grecian:2022}. The data are temporally irregular Argos locations including error ellipse information. We fit the `crw` model using `fit_ssm` with a 4 ms^-1^ speed filter threshold (`vmax`) and a 12-h prediction interval (`time.step`).

We simulate 50 animal movement paths from the `crw` process model using `simfit`, and apply a potential function using the `grad` and `beta` arguments to constrain the simulated paths to largely remain in water. These tracks are then filtered based on their similarity to the original path using `sim_filter` and the top 10% retained (`keep = 0.1`)(Fig. \ref{fig:ex33}a,b). As the potential function does not guarantee all locations remain off land, we re-route any remaining simulated locations from land back to water using `route_path` (Fig. \ref{fig:ex33}c). In combination, these functions provide a pragmatic, non-statistical method to generate and objectively filter pseudo-tracks for use in movement or habitat modelling applications. R code is available in Appendix S4 (Supporting Information).

```{r ex33, echo = FALSE, message = FALSE, results = 'markup', fig.width = 9, fig.height = 6, cache = TRUE, fig.cap = "\\label{fig:ex33} Simulating (a) 100 movement paths from a correlated random walk process model; (b) filtering those tracks to select the top 10% based on their similarity to the original SSM-predicted track (red); and (c) re-routing simulated locations on land (orange) back to ocean (blue). The orange box in (b) indicates region magnified in (c). SSM-predicted track (red) overlaid in all panels for context."}
# load track data
locs <- readRDS("../data/ex33.rds")

# load gradient rasters for simfit
load(system.file("extdata/grad.rda", package = "foieGras"))

# fit <- fit_ssm(locs %>% filter(id == "hp6-749-19"), 
#                model = "crw", 
#                time.step = 12, 
#                vmax = 4, 
#                control = ssm_control(verbose = 0))
# 
# set.seed(10000)
# trs <- foieGras::simfit(fit,
#               what = "predicted",
#               reps = 100,
#               grad = grad,
#               beta = c(-350, -350))
# 
# trs_flt <- foieGras::sim_filter(trs,
#                       keep = 0.1,
#                       flag = 2)
# 
# trs_flt_rr <- foieGras::route_path(trs_flt,
#                                 map_scale = 50,
#                                 buffer = 20000)

load("../data/ex33_fits.RData")

world_shp <- rnaturalearth::ne_countries(scale = 50, returnclass = "sf")

# To generate a plot with less distortion first define a projection i.e. Lambert Azimuthal Equal Area
prj <- "+proj=laea +lat_0=60 +lon_0=-50 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"

trs_sf <- trs %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

trs_flt_sf <- trs_flt %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

trs_flt_rr_sf <- trs_flt_rr %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

plocs_sf <- foieGras::grab(fit, "predicted", as_sf = TRUE) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

pline_sf <- foieGras::grab(fit, "predicted", as_sf = TRUE) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTILINESTRING")

bb_trs <- sf::st_bbox(trs_sf)  

p1 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(data = trs_sf, size = 0.2, colour = "dodgerblue") +
  geom_sf(data = plocs_sf, size = 0.5, colour = "firebrick") +
  coord_sf(xlim = c(bb_trs[1], bb_trs[3]), 
           ylim = c(bb_trs[2], bb_trs[4]), 
           crs = prj, 
           expand = TRUE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 20)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 15)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "br"))

## create box to magnify in subsequent maps
zbox <- structure(list(id = c(1,1,1,1,1), 
                          lon = c(-53, -68, -68, -53, -53), 
                          lat = c(45, 45, 51.25, 51.25, 45)), 
                  class = "data.frame", row.names = c(NA, -5L))
zbox_sf <- zbox %>%
  sf::st_as_sf(coords = c("lon","lat"), crs = 4326) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(geometry = sf::st_combine(geometry)) %>%
  sf::st_cast("POLYGON")

bb_zbox <- sf::st_bbox(zbox_sf)  

p2 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(size = 0.2, data = trs_flt_sf, colour = "dodgerblue") +
  geom_sf(data = plocs_sf, size = 0.4, colour = "firebrick") +
  geom_sf(data = zbox_sf, size = 0.75, colour = "orange", fill = NA) +
  coord_sf(xlim = c(bb_trs[1], bb_trs[3]), 
           ylim = c(bb_trs[2], bb_trs[4]), 
           crs = prj, 
           expand = TRUE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 20)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 15)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "br"))

world_shp <- rnaturalearth::ne_countries(scale = 10, returnclass = "sf")

p3 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(data = trs_flt_sf, colour = "orange", size = 0.8) +
  geom_sf(data = trs_flt_rr_sf, colour = "dodgerblue", size = 0.8) +
  geom_sf(data = pline_sf, size = 0.2, colour = "firebrick") +
  geom_sf(data = plocs_sf, size = 0.4, colour = "firebrick") +
  coord_sf(xlim = c(bb_zbox[1], bb_zbox[3]), 
           ylim = c(bb_zbox[2], bb_zbox[4]), 
           crs = prj, 
           expand = FALSE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 5)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 5)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "tl"))

p1 + p2 + p3 + 
  patchwork::plot_layout(ncol = 2) +
  patchwork::plot_annotation(tag_levels = "a") & 
  theme(plot.tag = element_text(size = 10))
```



