---
output:
  pdf_document: default
  html_document: default
  word_document: default
---
# 3 | Applications

```{r part_3_preamble, include=FALSE}
#### Code for part 3: Applications ####
```
We illustrate the main capabilities of `foieGras` with three applications. Complete R code for reproducing the applications and for gaining a deeper understanding of `foieGras` functions are provided in the Supporting Information (Appendices S1 - S4). Data used in the applications are available (currently on GitHub; will be Dryad if ms accepted) \url{https://github.com/ianjonsen/foieGras.paper/tree/main/SI/data}. Processing times for model fits and simulations in the applications are reported in their figure captions. All analyses conducted on a 2021 Apple MacBook Pro with an M1 Pro processor, 32 Gb Ram and R 4.3.

```{r ex31, echo=FALSE, message=FALSE, results='markup', fig.width=7, fig.height=7.5, cache=TRUE, fig.cap="\\label{fig:ex1} State-space model fits to a southern elephant seal track with finer scale detail inset (a), and diagnostic plots for assessing goodness-of-fit of the `rw` (b - prediction residual time-series; d - prediction residual autocorrelation) and `crw` (c,e) state-space models. All residual plots generated using the `plot.osar` function. Processing time: 2.5 s."}

load("../data/ex31.RData")

dat <- grab(fit.rw[1,], "d", as_sf = TRUE) |> 
  sf::st_transform("+proj=stere +lon_0=90 +units=km")
loc.rw <- grab(fit.rw[1,], "f", as_sf = TRUE) |>
  sf::st_transform("+proj=stere +lon_0=90 +units=km") 
line.rw <- loc.rw |>
  dplyr::group_by(id) |>
  dplyr::summarise(do_union = FALSE, .groups = "drop") |>
  sf::st_cast("MULTILINESTRING")
loc.crw <- grab(fit.crw[1,], "f", as_sf = TRUE) |>
  sf::st_transform("+proj=stere +lon_0=90 +units=km") 
line.crw <- loc.crw |>
  dplyr::group_by(id) |>
  dplyr::summarise(do_union = FALSE, .groups = "drop") |>
  sf::st_cast("MULTILINESTRING")

line.ssm <- bind_rows(line.rw, line.crw) |>
  mutate(SSM = c("rw","crw")) |>
  select(id, SSM, geometry)

## confidence ellipses
ssm.rw <- grab(fit.rw[1,], "f", as_sf=TRUE) %>% 
  sf::st_transform("+proj=stere +lon_0=90 +units=km")
xy <- sf::st_coordinates(ssm.rw)
ssm.rw <- bind_cols(ssm.rw, xy) %>% 
  rename(x=X, y=Y) %>%
  select(id,date, x, y, everything()) %>%
  split(., .$id)

conf_poly <- lapply(ssm.rw, function(x) {
          conf <- lapply(1:nrow(x), function(i)
            with(x, foieGras:::elps(x[i], y[i], x.se[i], y.se[i], 90)))
          tmp <- lapply(conf, function(x)
            sf::st_polygon(list(x)))
          sf::st_multipolygon(tmp)
        })

conf.rw_sf <- sf::st_as_sf(sf::st_as_sfc(conf_poly)) 
conf.rw_sf$id <- unique(fit.rw[1,]$id)

ssm.crw <- grab(fit.crw[1,], "f", as_sf=TRUE) %>% 
  sf::st_transform("+proj=stere +lon_0=90 +units=km")
xy <- sf::st_coordinates(ssm.crw)
ssm.crw <- bind_cols(ssm.crw, xy) %>% 
  rename(x=X, y=Y) %>%
  select(id,date, x, y, everything()) %>%
  split(., .$id)

conf_poly <- lapply(ssm.crw, function(x) {
          conf <- lapply(1:nrow(x), function(i)
            with(x, foieGras:::elps(x[i], y[i], x.se[i], y.se[i], 90)))
          tmp <- lapply(conf, function(x)
            sf::st_polygon(list(x)))
          sf::st_multipolygon(tmp)
        })

conf.crw_sf <- sf::st_as_sf(sf::st_as_sfc(conf_poly)) 
conf.crw_sf$id <- unique(fit.crw[1,]$id)

conf.ssm <- bind_rows(conf.rw_sf, conf.crw_sf) |>
  mutate(SSM = c("rw","crw")) |>
  select(id, SSM, x) |>
  rename(geometry = x)
sf::st_crs(conf.ssm) <- sf::st_crs(line.ssm)

zbox <- structure(list(id = c(1,1,1,1,1), 
                       lon = c(107, 110.25, 110.25, 107, 107), 
                       lat = c(-66.5, -66.5, -64.9, -64.9, -66.5)), 
                  class = "data.frame", row.names = c(NA, -5L))

prj <- sf::st_crs(line.ssm)

zbox_sf <- zbox %>%
  sf::st_as_sf(coords = c("lon","lat"), crs = 4326) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(geometry = sf::st_combine(geometry)) %>%
  sf::st_cast("POLYGON")

bb_zbox <- sf::st_bbox(zbox_sf)

pA <- ggplot() +
  geom_sf(data = dat, 
             col = "orange", 
             shape = 3,
             size = 1) +
  geom_sf(data = conf.ssm,
          aes(fill = SSM),
          colour = NA,
          alpha = 0.35) +
  geom_sf(data = line.ssm,
            aes(colour = SSM)) +
  geom_sf(data = zbox_sf, linewidth = 0.5, colour = "black", fill = NA) +
  scale_colour_manual(values = c("firebrick", "dodgerblue")) +
  scale_fill_manual(values = c("firebrick", "dodgerblue"), guide = "none") +
  labs(x = element_blank(), y = element_blank()) +
  theme_minimal() +
  theme(axis.text = element_text(size = 8),
        legend.key.size = unit(c(6, 3), "mm"),
        legend.title = element_text(size = 9),
        legend.text = element_text(size = 8),
        legend.position = c(0.2,0.2))

pAsub1 <- ggplot() +
  geom_sf(data = dat, 
             col = "orange", 
             shape = 3,
             size = 0.8) +
  geom_sf(data = conf.ssm,
          aes(fill = SSM),
          colour = NA,
          alpha = 0.05) +
  geom_sf(data = line.ssm,
            aes(colour = SSM),
          linewidth = 0.75) +
  coord_sf(xlim = c(bb_zbox[1], bb_zbox[3]), 
           ylim = c(bb_zbox[2], bb_zbox[4]), 
           crs = prj, 
           expand = FALSE) +
  scale_colour_manual(values = c("firebrick", "dodgerblue"), guide = "none") +
  scale_fill_manual(values = c("firebrick", "dodgerblue"), guide = "none") +
  labs(x = element_blank(), y = element_blank()) +
  theme_minimal() +
  theme(axis.text = element_blank(),
        panel.background = element_rect(colour = "white"),
        panel.border = element_rect(fill=NA, linewidth=0.5))

pAsub1 <- ggplotGrob(pAsub1)

foo <- sf::st_bbox(dat)

pAA <- pA + 
  annotation_custom(grob = pAsub1, 
                             xmin = foo$xmin + (foo$xmax - foo$xmin) * 0.35, 
                             xmax = foo$xmin + (foo$xmax - foo$xmin) * 1.30, 
                             ymin = foo$ymin + (foo$ymax - foo$ymin) * 0.35, 
                             ymax = foo$ymin + (foo$ymax - foo$ymin) * 1.05)

p1 <- plot(res.rw, "ts") + 
  xlab(element_blank()) + 
  ylab("Residuals") +
  theme(axis.text.x = element_text(size=7, angle=45), 
        axis.title.y = element_text(size = 8),
        strip.text.y = element_blank(),
        axis.title.x = element_blank())

p2 <- plot(res.rw, "acf") + 
  theme(strip.text.y = element_blank(),
        axis.text = element_text(size = 8),
        axis.title = element_text(size = 8))

p3 <- plot(res.crw, "ts") + 
  ylab(element_blank()) + 
  xlab(element_blank()) + 
  theme(axis.text.x = element_text(size=7, angle=45), 
        strip.text.y = element_blank(),
        axis.title.x = element_blank())

p4 <- plot(res.crw, "acf") + 
  ylab(element_blank()) + 
  theme(strip.text.y = element_blank(),
        axis.text = element_text(size = 8),
        axis.title = element_text(size = 8))

pAA / (p1 | p3) / (p2 | p4) +
  patchwork::plot_layout(widths = c(3,3,3),
              heights = c(3,1,1)) +
  patchwork::plot_annotation(tag_levels = "a") &
  theme(plot.tag = element_text(size = 9))
```

## 3.1 | SSM validation with prediction residuals
We use a sub-adult male southern elephant seal (*Mirounga leonina*) track included as example data in `foieGras` (`sese2`, id: ct36-E-09), sourced from from the Australian Integrated Marine Observing System (IMOS; data publicly available via [imos.aodn.org.au](http://imos.aodn.org.au)) deployments at Iles Kerguelen. The data are temporally irregular Argos Least-Squares locations. We fitted both the `rw` and `crw` models using `fit_ssm()` with a speed filter threshold (`vmax`) of 4 ms^-1^ and a 12-h time step. We calculated prediction residuals using `osar()`, and then plotted the `osar` residuals to assess and compare the model fits (Fig. \ref{fig:ex1}).  

Plots of predicted states with the observations suggest both models yield similar global fits (Fig. \ref{fig:ex1}a; compare blue versus red lines and 95\% confidence ellipses), but discrepancies are visible at a finer scale (Fig. \ref{fig:ex1}a, inset). Predicted locations from the two models differ by a median 6.62 km (range: 0.02, 53.02 km), and there are marked trends in the residuals for the `rw` model fit (Fig. \ref{fig:ex1}b) with significant positive autocorrelation in both the x and y directions (Fig. \ref{fig:ex1}d). The `crw` prediction residuals have no temporal trend and little autocorrelation (Fig. \ref{fig:ex1}c,e), implying the `crw` process model is a better fit to the data.

Although the `crw` process model provides a better fit, confidence ellipses around fitted and predicted location estimates should be examined. The `plot.ssm_df` function allows estimated location uncertainty to be visualized as 95\% confidence intervals/ellipses in 1 (`type = 1`) or 2 dimensions (`type = 2`). When confidence ellipses are large, use of the location estimates without acknowledging their uncertainty in subsequent analyses may lead to biased results.

## 3.2 | Inferring move persistence  
To illustrate how move persistence ($\gamma_t$) can be estimated from GPS data, we use four little penguin (*Eudyptula minor*) tracks of daily foraging trips during the chick-rearing period from Montague Island, NSW, Australia \citep[described in][]{Phillips:2022}. The data are temporally irregular GPS locations, with high frequency sampling (mean 15 s) intermittently disrupted by the birds' diving behaviour, and are assumed to have minimal measurement error. We fitted the `crw` SSM to the GPS data to predict locations at regular 2-min intervals, and assumed consistently small bivariate normal location measurement errors (ie. $\pm$ 30 m sd). We then used `fit_mpm` to estimate $\gamma_t$ from these regularized locations. As $\gamma_t$ estimates are sensitive to time interval choice, we compare 2-min estimates with those from both shorter and longer prediction intervals. Finally, we visually compared $\gamma_t$ estimates with prey capture events inferred from accelerometry data \citep[see][for details]{Carroll:2014} to ascertain whether reduced $\gamma_t$ can indicate active foraging by these penguins. We provide an extra application to show how move persistence can be inferred from Argos data using `fit_ssm` (Appendix S3).

\blandscape
```{r ex32, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, fig.width=9, fig.height=5, results='markup', cache=TRUE, fig.cap="\\label{fig:ex32} Inferred move persistence, $\\gamma_t$, from time-regularised little penguin GPS tracks. $\\gamma_t$ estimates were compared across a range of prediction intervals (0.5 to 16 min; a,c,e,g; 2-min in bold orange). The 2-min $\\gamma_t$ estimates for each penguin are overlaid with the number of prey capture events, inferred from accelerometry data (black circles in b,d,f,h; grey envelopes are 95 % CI's) and along SSM-predicted penguin tracks (i). Location symbol sizes in (i) are proportional to the number of prey capture events at 2-min intervals corresponding to the SSM predicted location times. Processing time: 4.091 min."}
load("../data/ex32_lipe.RData")

## generate time-series plots of move persistence
p <- plot(fmp2, ncol = 1, pages = 1, ask = FALSE, pal = "Plasma") &
  theme(legend.position = "none",
        plot.title = element_blank(),
        axis.text = element_text(size = 6),
        panel.grid.minor = element_blank())
## adjust x-axis date labels for clean manuscript figure
p[[1]] <- p[[1]] & 
  scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
p[[2]] <- p[[2]] & 
  scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
p[[3]] <- p[[3]] & 
  scale_x_datetime(date_breaks = "4 hours", date_labels = "%H:%M")
p[[4]] <- p[[4]] & 
  scale_x_datetime(date_breaks = "5 hours", date_labels = "%H:%M")

## function to merge track & predation events
merge.tracks.preds <- function(tracks, preds){
  # drop tracks not in events
  tracks$id <- as.character(tracks$id)
  tracks <- tracks[tracks$id %in% unique(preds$id),]
  tracks$preyCount <- 0

  predsl <- split(preds, with(preds, interaction(id)), drop = TRUE)
  # Unique events
  uniqueEventsl2 <- lapply(predsl, 
                           function(x) x[round(diff(as.POSIXct(x$date))) > 2,])

  # Loop events
  tracks <- split(tracks, tracks$id)
  for (i in 1:length(tracks)){
    # go through events and find the nearest track timestamp for each
    events <- uniqueEventsl2[[tracks[[i]]$id[1]]]
    events$idx <- sapply(events$date, function(dt)
      which.min(abs(as.numeric(difftime(dt, tracks[[i]]$date, unit='sec')))))
    # populate tracks
    for (idx in unique(events$idx)){
      tracks[[i]]$preyCount[idx] <- sum(events$idx == idx)
    }
  }
  # merge tracks back together
  tracks <- do.call(rbind, tracks)
  row.names(tracks) <- NULL
  return(tracks)
}

peng.ssm_sf <- grab(fit2, "p", as_sf = TRUE)

## aggregate prey capture events to SSM location times & append
peng.ssm_sf <- merge.tracks.preds(peng.ssm_sf, svm.pc)

## append move persistence estimates
peng.ssm_sf <- peng.ssm_sf %>% mutate(g = grab(fmp2, "f")$g)

## update move persistence time-series plot with prey captures
## first, normalise preyCount to 0,1
p[[1]] <- suppressMessages(p[[1]] + geom_point(data = subset(peng.ssm_sf,
                                            id == "G123f02"),
                              aes(date, preyCount * 0.091), 
                              size = 0.2) +
  scale_y_continuous(expression(gamma[t]), 
                     limits = c(0,1),
                     sec.axis = sec_axis(~ ./0.091, name = "")
                     ))

p[[2]] <- suppressMessages(p[[2]] + geom_point(data = subset(peng.ssm_sf,
                                            id == "G124m10"),
                              aes(date, preyCount * 0.091), 
                              size = 0.2) +
  scale_y_continuous(expression(gamma[t]), 
                     limits = c(0,1),
                     sec.axis = sec_axis(~ ./0.091, name = "")
                     ))

p[[3]] <- suppressMessages(p[[3]] + geom_point(data = subset(peng.ssm_sf,
                                            id == "G126m05"),
                              aes(date, preyCount * 0.091), 
                              size = 0.2) +
  scale_y_continuous(expression(gamma[t]), 
                     limits = c(0,1),
                     sec.axis = sec_axis(~ ./0.091, name = "")
                     ))

p[[4]] <- suppressMessages(p[[4]] + geom_point(data = subset(peng.ssm_sf,
                                            id == "L013m01"),
                              aes(date, preyCount * 0.091), 
                              size = 0.2) +
  scale_y_continuous(expression(gamma[t]), 
                     limits = c(0,1),
                     sec.axis = sec_axis(~ ./0.091, name = "")
                     ))

## expand limits to preserve map boundaries
bb <- sf::st_bbox(peng.ssm_sf)
bb["xmin"] <- bb["xmin"] - diff(bb[c(1,3)]) * 0.7/2
bb["xmax"] <- bb["xmax"] + diff(bb[c(1,3)]) * 0.3/2
bb["ymin"] <- bb["ymin"] - diff(bb[c(2,4)]) * 0.2/2
bb["ymax"] <- bb["ymax"] + diff(bb[c(2,4)]) * 0.2/2

my.aes <- aes_lst(conf = F, line = T, mp_pal = hcl.colors(n=100, "Plasma"))
my.aes$df$size[1] <- 1

m <- map(
  fit2,
  fmp2,
  what = "p",
  aes = my.aes,
  map_type = "cartolight",
  zoomin = 1,
  normalise = FALSE,
  silent = TRUE
) + 
  geom_sf(data=peng.ssm_sf %>% filter(preyCount > 0), 
          aes(size = preyCount, fill = g), 
          shape = 21, 
          stroke = 0.3,
          inherit.aes = TRUE) +
  scale_size(breaks = c(1,5,10), 
             range = c(1, 4), 
             name = "prey\ncaptures",
             guide = "none") +
  scale_fill_viridis_c(option = "C", 
                       begin = min(peng.ssm_sf$g), 
                       end = max(peng.ssm_sf$g),
                       guide = "none") +
  ggspatial::annotation_scale(height = unit(0.15, "cm"), 
                              aes(location = "br")) +
  xlab(element_blank()) +
  ylab(element_blank()) +
  coord_sf(xlim = bb[c(1,3)], 
            ylim = bb[c(2,4)], 
            expand = TRUE, 
            crs = sf::st_crs(peng.ssm_sf)) +
  scale_x_continuous(breaks = pretty(seq(150.13, 150.26, l = 4), n = 3)) +
  scale_y_continuous(breaks = pretty(seq(-36.5, -36.24, l = 5), n = 4)) +
  theme(legend.position = c(0.25,0.05),
        legend.direction = "horizontal",
        legend.key.width = unit(5, "mm"),
        legend.title = element_text(size = 8),
        legend.text = element_text(size = 6),
        axis.text = element_text(size = 6),
        panel.grid = element_line(colour = grey(0.7), linewidth = 0.01),
        panel.background = element_blank(),
        panel.ontop = TRUE)

label.df <- data.frame(tag = c("b","d","f","h"), 
                        x = c(0.3, 0.8, 0.15, 0.83) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                        y = c(0.85, 0.15, 0.4, 0.5) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"])
names.df <- data.frame(tag = c("Montague\nIsland"),
                       x = 0.92 * (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                       y = 0.91 * (bb["ymax"] - bb["ymin"]) + bb["ymin"])

m <- m + 
  geom_text(data = label.df, aes(x,y,label=tag), size = 3) +
  geom_text(data = names.df, aes(x,y,label=tag), size = 2.5)

## make custom prey capture legend for location symbol size
pc.title <- data.frame(tag = "prey\ncaptures",
                       x = 0.05 * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                       y = 0.1 * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"])
pc.df <- data.frame(x = c(0.15, 0.205, 0.26, 0.33) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                    y = rep(0.11, 4) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"],
                    size = c(1, 1, 6, 12))
pc.labels <- data.frame(x = c(0.15, 0.205, 0.26, 0.33) * 
                         (bb["xmax"] - bb["xmin"]) + bb["xmin"],
                    y = rep(0.08, 4) * 
                         (bb["ymax"] - bb["ymin"]) + bb["ymin"],
                    tag = c("0", "1", "5", "10"))

m <- m +
  geom_text(data = pc.title, 
            aes(x, y, label = tag), 
            size = 2, 
            inherit.aes = FALSE) +
  geom_point(data = pc.df[1,], 
             aes(x, y), 
             shape = 21,
             size = 1, 
             fill = "#EDB300",
             colour = "#EDB300",
             inherit.aes = FALSE,
             show.legend = FALSE) +
  geom_point(data = pc.df[2:4,], 
             aes(x, y, size = size), 
             shape = 21,
             stroke = 0.3,
             fill = NA,
             inherit.aes = FALSE,
             show.legend = FALSE) +
  geom_text(data = pc.labels,
            aes(x, y, label = tag), 
            size = 2,
            inherit.aes = FALSE)

## move persistence estimates at different time scales
ggp <- lapply(1:4, function(i) {
  g05 <- grab(fmp05, "f") %>% filter(id == unique(id)[i])
  g1 <- grab(fmp1, "f") %>% filter(id == unique(id)[i])
  g2 <- grab(fmp2, "f") %>% filter(id == unique(id)[i])
  g4 <- grab(fmp4, "f") %>% filter(id == unique(id)[i])
  g8 <- grab(fmp8, "f") %>% filter(id == unique(id)[i])
  g16 <- grab(fmp16, "f") %>% filter(id == unique(id)[i])
  gg <- bind_rows(g05, g1, g2, g4, g8, g16) %>%
    mutate(interval = rep(c(0.5, 1, 2, 4, 8, 16),
                          c(
                            nrow(g05), nrow(g1), nrow(g2),
                            nrow(g4), nrow(g8), nrow(g16)
                          ))) %>%
    mutate(interval = as.factor(interval))
  
  p <- ggplot() +
    geom_path(data = gg, aes(date, g, colour = interval,
                             group = interval)) +
    geom_path(
      data = gg %>% filter(interval == 2),
      aes(date, g),
      colour = "#FB8072",
      linewidth = 1
    ) +
    scale_colour_manual(
      values = c(
        "#FFFFB3",
        "#BEBADA",
        "#FB8072",
        "#8DD3C7",
        "#FDB462",
        "#80B1D3"
      ),
      name = "prediction\ninterval (min)"
    ) +
    ylim(0, 1) +
    theme_grey() +
    theme(
      legend.title = element_text(size = 6),
      axis.title.y = element_text(size = 10),
      legend.position = "none",
      axis.text = element_text(size = 6),
      panel.grid.minor = element_blank()
    ) +
    xlab(element_blank()) +
    ylab(expression(gamma[t]))
  
  if(i==4) {
    p <- p + theme(legend.position = "bottom", #c(0.5, 0.12),
      legend.direction = "horizontal",
      legend.key.width = unit(0.03, "npc"),
      legend.key.height = unit(0.0001, "npc"),
      legend.text = element_text(size = 6),
      legend.background = element_blank())
  }
  return(p)
})

ggp[[1]] <- ggp[[1]] + 
    scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
ggp[[2]] <- ggp[[2]] + 
    scale_x_datetime(date_breaks = "3 hours", date_labels = "%H:%M")
ggp[[3]] <- ggp[[3]] + 
    scale_x_datetime(date_breaks = "4 hours", date_labels = "%H:%M")
ggp[[4]] <- ggp[[4]] + 
    scale_x_datetime(date_breaks = "5 hours", date_labels = "%H:%M")

design <- "
1299
3499
5699
7899
"

## plot movement persistence 1-D time-series and map along 2-D tracks
ggp[[1]] + p[[1]] + ggp[[2]] + p[[2]] + ggp[[3]] + p[[3]] + ggp[[4]] + p[[4]] + m +
  patchwork::plot_layout(design = design) +
  patchwork::plot_annotation(tag_levels = "a") &
  theme(plot.tag = element_text(size = 9))
 grid::grid.draw(grid::textGrob("Number of prey captures per 2 min", 
                                x = 0.55, y = 0.55, rot = 270, 
                                gp = grid::gpar(fontsize = 10)))
```


\elandscape

As $\gamma_t$ is sensitive to choice of prediction time interval, it is important that a range of intervals be evaluated. Although the chosen 2-min prediction interval is longer than the GPS sampling frequency (15 s), it adequately captures the main changes in $\gamma_t$ (Fig. \ref{fig:ex32}a,c,e,g). Shorter intervals (0.5 and 1 min) have substantial short-term variability that may not reflect real changes in movement pattern, while longer intervals (8 and 16 min) likely smooth out too much real variability in the movements.

The little penguin GPS tracks did not exhibit strong contrast in move persistence ($\gamma_t$ range = 0.102, 0.871; Fig. \ref{fig:ex32}b,d,f,h). Nonetheless, the move persistence estimates highlight changes in movement pattern over the course of the penguins' daily foraging trips (Fig. \ref{fig:ex32}i). The penguins departed Montague Is. with relatively fast movements, three directed southward (Fig. \ref{fig:ex32} tracks d,f,h in i) and one less directed and remaining closer to the island (track b), before slowing down and engaging in meandering movements (orange - purple in Fig. \ref{fig:ex32}i). The high $\gamma_t$ estimates at the start of the penguins' foraging trips were associated with few prey captures (Fig. \ref{fig:ex32}b,d,f). However, periods of lower $\gamma_t$ were only loosely associated with higher prey captures. For example, penguin "h" had no prey captures as $\gamma_t$ declined toward the end of its foraging trip (Fig. \ref{fig:ex32}h). This period of lower $\gamma_t$ is likely indicative of resting as returning penguins usually wait offshore until after dusk before hauling out on the island. These results highlight that while move persistence can objectively indicate where animals spend more (low $\gamma_t$) or less (high $\gamma_t$) time, the behaviour(s) responsible for these patterns may not be obvious or consistent \citep[e.g.,][]{Riaz:2021}.


## 3.3 | Simulating tracks from `foieGras` model fits

To illustrate how to simulate tracks from `foieGras` model fits we use a juvenile harp seal (*Pagophilus groenlandicus*) tracked from the Gulf of St Lawrence, Canada, \citep[described in][]{Grecian:2022}. The data are temporally irregular Argos locations including error ellipse information. We fit the `crw` model using `fit_ssm` with a 4 ms^-1^ speed filter threshold (`vmax`) and a 12-h prediction interval (`time.step`).

We simulate 50 animal movement paths from the `crw` process model using `sim_fit`, and apply a potential function using the `grad` and `beta` arguments to constrain the simulated paths to largely remain in water. These tracks are then filtered based on their similarity to the original path using `sim_filter` and the top 25 % retained (`keep = 0.25`)(Fig. \ref{fig:ex33}a,b). As the potential function does not guarantee all locations remain off land, we re-route any remaining simulated locations from land back to water using `route_path` (Fig. \ref{fig:ex33}c). In combination, these functions provide a pragmatic, non-statistical method to generate and objectively filter pseudo-tracks for use in movement or habitat modelling applications.

```{r ex33, echo = FALSE, message = FALSE, results = 'markup', fig.width = 6, fig.height = 6, cache = TRUE, fig.cap = "\\label{fig:ex33} Simulating (a) 100 movement paths from a correlated random walk process model; (b) filtering those tracks to select the top 25% based on their similarity to the original SSM-predicted track (red); and (c) re-routing simulated locations on land (orange) back to ocean (blue). The orange box in (b) indicates region magnified in (c). SSM-predicted track (red) overlaid in all panels for context. Processing time: 2.18 min."}
# load track data
locs <- readRDS("../data/ex33.rds")

# load gradient rasters for sim_fit
load(system.file("extdata/grad.rda", package = "foieGras"))

# fit <- fit_ssm(locs %>% filter(id == "hp6-749-19"), 
#                model = "crw", 
#                time.step = 12, 
#                vmax = 4, 
#                control = ssm_control(verbose = 0))
# 
# set.seed(10000)
# trs <- foieGras::sim_fit(fit,
#               what = "predicted",
#               reps = 100,
#               grad = grad,
#               beta = c(-350, -350))
# 
# trs_flt <- foieGras::sim_filter(trs,
#                       keep = 0.25,
#                       flag = 2)
# 
# trs_flt_rr <- foieGras::route_path(trs_flt,
#                                 map_scale = 50,
#                                 buffer = 20000)

load("../data/ex33_fits.RData")

world_shp <- rnaturalearth::ne_countries(scale = 50, returnclass = "sf")

# To generate a plot with less distortion first define a projection i.e. Lambert Azimuthal Equal Area
prj <- "+proj=laea +lat_0=60 +lon_0=-50 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"

trs_sf <- trs %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

trs_flt_sf <- trs_flt %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

trs_flt_rr_sf <- trs_flt_rr %>% 
  tidyr::unnest(cols = c(sims)) %>% 
  sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  sf::st_transform(crs = prj) %>%
  group_by(id, rep) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

plocs_sf <- foieGras::grab(fit, "predicted", as_sf = TRUE) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTIPOINT")

pline_sf <- foieGras::grab(fit, "predicted", as_sf = TRUE) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(do_union = FALSE, .groups = "drop") %>%
  sf::st_cast("MULTILINESTRING")

bb_trs <- sf::st_bbox(trs_sf)  

p1 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(data = trs_sf, size = 0.2, colour = "dodgerblue") +
  geom_sf(data = plocs_sf, size = 0.5, colour = "firebrick") +
  coord_sf(xlim = c(bb_trs[1], bb_trs[3]), 
           ylim = c(bb_trs[2], bb_trs[4]), 
           crs = prj, 
           expand = TRUE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 20)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 15)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "br"))

## create box to magnify in subsequent maps
zbox <- structure(list(id = c(1,1,1,1,1), 
                          lon = c(-53, -68, -68, -53, -53), 
                          lat = c(45, 45, 51.25, 51.25, 45)), 
                  class = "data.frame", row.names = c(NA, -5L))
zbox_sf <- zbox %>%
  sf::st_as_sf(coords = c("lon","lat"), crs = 4326) %>%
  sf::st_transform(crs = prj) %>%
  group_by(id) %>%
  summarise(geometry = sf::st_combine(geometry)) %>%
  sf::st_cast("POLYGON")

bb_zbox <- sf::st_bbox(zbox_sf)  

p2 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(size = 0.2, data = trs_flt_sf, colour = "dodgerblue") +
  geom_sf(data = plocs_sf, size = 0.4, colour = "firebrick") +
  geom_sf(data = zbox_sf, size = 0.75, colour = "orange", fill = NA) +
  coord_sf(xlim = c(bb_trs[1], bb_trs[3]), 
           ylim = c(bb_trs[2], bb_trs[4]), 
           crs = prj, 
           expand = TRUE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 20)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 15)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "br"))

world_shp <- rnaturalearth::ne_countries(scale = 10, returnclass = "sf")

p3 <- ggplot() +
  theme_minimal() +
  geom_sf(data = world_shp, colour = NA, fill = grey(0.6)) +
  geom_sf(data = trs_flt_sf, colour = "orange", size = 0.8) +
  geom_sf(data = trs_flt_rr_sf, colour = "dodgerblue", size = 0.8) +
  geom_sf(data = pline_sf, linewidth = 0.2, colour = "firebrick") +
  geom_sf(data = plocs_sf, size = 0.4, colour = "firebrick") +
  coord_sf(xlim = c(bb_zbox[1], bb_zbox[3]), 
           ylim = c(bb_zbox[2], bb_zbox[4]), 
           crs = prj, 
           expand = FALSE) +
  scale_x_continuous(breaks = seq(from = -180, to = 180, by = 5)) +
  scale_y_continuous(breaks = seq(from = 0, to = 90, by = 5)) +
  ggspatial::annotation_scale(height = unit(1.5, "mm"), aes(location = "tl"))

p1 + p2 + p3 + 
  patchwork::plot_layout(ncol = 2) +
  patchwork::plot_annotation(tag_levels = "a") & 
  theme(plot.tag = element_text(size = 10))
```



